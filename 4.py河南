import re
import requests
import logging
from collections import OrderedDict
from datetime import datetime
from typing import Dict, List, Tuple, Set
import config
import concurrent.futures
import time

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("function.log", "w", encoding="utf-8"),
        logging.StreamHandler()
    ]
)


class ChannelProcessor:
    """频道处理器"""
    
    def __init__(self):
        self.written_urls: Set[str] = set()
    
    def parse_template(self, template_file: str) -> OrderedDict:
        """解析模板文件"""
        template_channels = OrderedDict()
        current_category = None

        try:
            with open(template_file, "r", encoding="utf-8") as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    
                    if "#genre#" in line:
                        current_category = line.split(",")[0].strip()
                        template_channels[current_category] = []
                    elif current_category:
                        channel_name = line.split(",")[0].strip()
                        if channel_name:  # 确保频道名不为空
                            template_channels[current_category].append(channel_name)
            
            logging.info(f"模板文件 '{template_file}' 解析成功，共 {len(template_channels)} 个分类")
            return template_channels
            
        except FileNotFoundError:
            logging.error(f"模板文件 '{template_file}' 未找到")
            raise
        except Exception as e:
            logging.error(f"解析模板文件时出错: {e}")
            raise

    def fetch_channels(self, url: str) -> OrderedDict:
        """从URL获取频道数据"""
        channels = OrderedDict()

        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            response.encoding = 'utf-8'
            lines = response.text.splitlines()
            
            # 检测文件格式
            is_m3u = any("#EXTINF" in line for line in lines[:10])
            source_type = "m3u" if is_m3u else "txt"
            logging.info(f"URL: {url} 获取成功，格式: {source_type}")

            if is_m3u:
                self._parse_m3u_format(lines, channels)
            else:
                self._parse_txt_format(lines, channels)

            if channels:
                categories = ", ".join(channels.keys())
                logging.info(f"URL: {url} 解析成功✅，分类: {categories}")
            else:
                logging.warning(f"URL: {url} 未解析到任何频道数据")

        except requests.RequestException as e:
            logging.error(f"URL: {url} 获取失败❌, 错误: {e}")
        except Exception as e:
            logging.error(f"URL: {url} 解析失败❌, 错误: {e}")

        return channels

    def _parse_m3u_format(self, lines: List[str], channels: OrderedDict):
        """解析M3U格式"""
        current_category = None
        channel_name = None
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            if line.startswith("#EXTINF"):
                match = re.search(r'group-title="(.*?)",(.*)', line)
                if match:
                    current_category = match.group(1).strip()
                    channel_name = match.group(2).strip()
                    if current_category not in channels:
                        channels[current_category] = []
            elif line and not line.startswith("#") and current_category and channel_name:
                channel_url = line.strip()
                channels[current_category].append((channel_name, channel_url))
                channel_name = None  # 重置频道名

    def _parse_txt_format(self, lines: List[str], channels: OrderedDict):
        """解析TXT格式"""
        current_category = None
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            if "#genre#" in line:
                current_category = line.split(",")[0].strip()
                channels[current_category] = []
            elif current_category and line:
                # 处理可能的格式：频道名,URL 或 只有频道名
                if "," in line:
                    parts = line.split(",", 1)
                    channel_name = parts[0].strip()
                    channel_url = parts[1].strip() if len(parts) > 1 else ''
                else:
                    channel_name = line
                    channel_url = ''
                
                if channel_name:
                    channels[current_category].append((channel_name, channel_url))

    def is_henan_mobile_unicom_url(self, url: str) -> bool:
        """检查是否为河南移动或联通源"""
        # 河南移动关键词
        mobile_keywords = [
            '移动', 'mobile', 'CMCC', 'cmcc', 'yd.', '.yd', 'hnyidong', 'henanmobile',
            '河南移动', 'haim', 'ha.m', 'ha-m', 'hndt', 'hntv', 'hnyd'
        ]
        
        # 河南联通关键词
        unicom_keywords = [
            '联通', 'unicom', 'CUCC', 'cucc', 'lt.', '.lt', 'hnunicom', 'henanunicom',
            '河南联通', 'hail', 'ha.l', 'ha-l', 'hnlt'
        ]
        
        # 检查URL是否包含河南移动或联通关键词
        url_lower = url.lower()
        
        # 检查移动源
        for keyword in mobile_keywords:
            if keyword in url_lower:
                return True
                
        # 检查联通源
        for keyword in unicom_keywords:
            if keyword in url_lower:
                return True
                
        return False

    def test_url_speed(self, url: str) -> float:
        """测试URL响应速度（毫秒）"""
        try:
            start_time = time.time()
            response = requests.get(url, timeout=5, stream=True)
            response.close()
            end_time = time.time()
            speed = (end_time - start_time) * 1000  # 转换为毫秒
            
            # 记录速度信息
            logging.debug(f"URL测试: {url} - 响应时间: {speed:.2f}ms")
            return speed
            
        except Exception as e:
            logging.debug(f"URL测试失败: {url}, 错误: {e}")
            return float('inf')  # 无法访问的URL返回无限大

    def filter_best_henan_urls(self, urls: List[str], max_urls: int = 3) -> List[str]:
        """筛选河南移动和联通最好的URL"""
        if not urls:
            return []
            
        # 首先筛选出河南移动和联通的URL
        henan_urls = [url for url in urls if self.is_henan_mobile_unicom_url(url)]
        
        # 如果没有找到河南移动联通的URL，则使用所有URL
        if not henan_urls:
            logging.info("未找到河南移动/联通源，使用所有可用源")
            henan_urls = urls
        else:
            logging.info(f"找到 {len(henan_urls)} 个河南移动/联通源")
        
        if len(henan_urls) <= max_urls:
            return henan_urls
            
        # 使用多线程测试URL速度
        logging.info(f"开始测试 {len(henan_urls)} 个URL的速度...")
        with concurrent.futures.ThreadPoolExecutor(max_workers=min(10, len(henan_urls))) as executor:
            future_to_url = {executor.submit(self.test_url_speed, url): url for url in henan_urls}
            speeds = {}
            
            for future in concurrent.futures.as_completed(future_to_url):
                url = future_to_url[future]
                try:
                    speed = future.result()
                    speeds[url] = speed
                except Exception as e:
                    speeds[url] = float('inf')
                    logging.debug(f"测试URL速度失败: {url}, 错误: {e}")
        
        # 按速度排序（从小到大），取前max_urls个
        sorted_urls = sorted(henan_urls, key=lambda url: speeds.get(url, float('inf')))
        best_urls = sorted_urls[:max_urls]
        
        # 记录最佳URL的速度信息
        logging.info(f"筛选出的最佳URL ({len(best_urls)} 个):")
        for i, url in enumerate(best_urls):
            speed = speeds.get(url, float('inf'))
            url_type = "河南移动/联通" if self.is_henan_mobile_unicom_url(url) else "其他"
            if speed != float('inf'):
                logging.info(f"  线路{i+1}: {url_type} - 响应时间: {speed:.2f}ms")
            else:
                logging.info(f"  线路{i+1}: {url_type} - 无法访问")
        
        return best_urls

    def match_channels(self, template_channels: OrderedDict, all_channels: OrderedDict) -> OrderedDict:
        """匹配模板频道和在线频道"""
        matched_channels = OrderedDict()

        for category, channel_list in template_channels.items():
            matched_channels[category] = OrderedDict()
            for channel_name in channel_list:
                found_urls = []
                for online_category, online_channel_list in all_channels.items():
                    for online_channel_name, online_channel_url in online_channel_list:
                        if channel_name == online_channel_name and online_channel_url:
                            found_urls.append(online_channel_url)
                
                # 为每个频道筛选最好的河南移动联通URL
                if found_urls:
                    best_urls = self.filter_best_henan_urls(found_urls, max_urls=3)
                    if best_urls:
                        matched_channels[category][channel_name] = best_urls
                        logging.info(f"频道 '{channel_name}' 找到 {len(best_urls)} 个优质源")
                    else:
                        logging.warning(f"频道 '{channel_name}' 未找到合适的源")
            
            # 记录匹配结果
            matched_count = len(matched_channels[category])
            total_urls = sum(len(urls) for urls in matched_channels[category].values())
            logging.info(f"分类 '{category}': 模板频道 {len(channel_list)} 个, 匹配成功 {matched_count} 个, 总URL数 {total_urls}")

        return matched_channels

    def filter_source_urls(self, template_file: str) -> Tuple[OrderedDict, OrderedDict]:
        """过滤源URL"""
        template_channels = self.parse_template(template_file)
        source_urls = config.source_urls

        all_channels = OrderedDict()
        for url in source_urls:
            fetched_channels = self.fetch_channels(url)
            for category, channel_list in fetched_channels.items():
                if category in all_channels:
                    all_channels[category].extend(channel_list)
                else:
                    all_channels[category] = channel_list

        matched_channels = self.match_channels(template_channels, all_channels)
        return matched_channels, template_channels

    def is_ipv6(self, url: str) -> bool:
        """检查是否为IPv6地址"""
        return re.match(r'^https?://\[[0-9a-fA-F:]+\]', url) is not None

    def update_channel_urls_m3u(self, channels: OrderedDict, template_channels: OrderedDict):
        """更新频道URL并生成M3U和TXT文件"""
        self.written_urls.clear()

        # 更新公告日期
        current_date = datetime.now().strftime("%Y-%m-%d")
        for group in config.announcements:
            for announcement in group['entries']:
                if announcement.get('name') is None:
                    announcement['name'] = current_date

        try:
            with open("live.m3u", "w", encoding="utf-8") as f_m3u, \
                 open("live.txt", "w", encoding="utf-8") as f_txt:
                
                # 写入M3U头
                epg_urls_str = ",".join(f'"{epg_url}"' for epg_url in config.epg_urls)
                f_m3u.write(f"#EXTM3U x-tvg-url={epg_urls_str}\n")

                # 写入公告频道
                self._write_announcements(f_m3u, f_txt)
                
                # 写入普通频道
                self._write_regular_channels(f_m3u, f_txt, channels, template_channels)

            logging.info("频道文件生成成功: live.m3u, live.txt")

        except IOError as e:
            logging.error(f"写入文件失败: {e}")
            raise

    def _write_announcements(self, f_m3u, f_txt):
        """写入公告频道"""
        for group in config.announcements:
            f_txt.write(f"{group['channel']},#genre#\n")
            for announcement in group['entries']:
                name = announcement['name']
                logo = announcement.get('logo', '')
                url = announcement['url']
                
                f_m3u.write(f'#EXTINF:-1 tvg-id="1" tvg-name="{name}" tvg-logo="{logo}" group-title="{group["channel"]}",{name}\n')
                f_m3u.write(f"{url}\n")
                f_txt.write(f"{name},{url}\n")

    def _write_regular_channels(self, f_m3u, f_txt, channels: OrderedDict, template_channels: OrderedDict):
        """写入普通频道"""
        for category, channel_list in template_channels.items():
            f_txt.write(f"{category},#genre#\n")
            
            if category in channels:
                for channel_name in channel_list:
                    if channel_name in channels[category]:
                        self._write_channel_urls(f_m3u, f_txt, category, channel_name, channels[category][channel_name])
                    else:
                        logging.warning(f"频道未找到: {channel_name} (分类: {category})")

    def _write_channel_urls(self, f_m3u, f_txt, category: str, channel_name: str, urls: List[str]):
        """写入频道URL"""
        if not urls:
            logging.warning(f"频道 '{channel_name}' 无可用URL")
            return

        # 排序URL（IPv6优先或IPv4优先）
        ipv6_priority = config.ip_version_priority == "ipv6"
        sorted_urls = sorted(urls, key=lambda url: not self.is_ipv6(url) if ipv6_priority else self.is_ipv6(url))
        
        # 过滤URL
        filtered_urls = []
        for url in sorted_urls:
            if (url and url not in self.written_urls and 
                not any(blacklist in url for blacklist in config.url_blacklist)):
                filtered_urls.append(url)
                self.written_urls.add(url)

        if not filtered_urls:
            logging.warning(f"频道 '{channel_name}' 无可用URL")
            return

        # 写入URL
        total_urls = len(filtered_urls)
        for index, url in enumerate(filtered_urls, start=1):
            new_url = self._format_channel_url(url, total_urls, index)
            self._write_channel_entry(f_m3u, f_txt, category, channel_name, new_url, index)

    def _format_channel_url(self, url: str, total_urls: int, index: int) -> str:
        """格式化频道URL"""
        is_ipv6_url = self.is_ipv6(url)
        is_henan_url = self.is_henan_mobile_unicom_url(url)
        base_url = url.split('$', 1)[0] if '$' in url else url
        
        # 标记河南移动联通源
        network_type = "河南移动联通" if is_henan_url else "其他网络"
        
        if total_urls == 1:
            suffix = f"$LR•{network_type}" 
        else:
            suffix = f"$LR•{network_type}『线路{index}』"
        
        return f"{base_url}{suffix}"

    def _write_channel_entry(self, f_m3u, f_txt, category: str, channel_name: str, url: str, index: int):
        """写入频道条目"""
        logo_url = f"https://gcore.jsdelivr.net/gh/yuanzl77/TVlogo@master/png/{channel_name}.png"
        
        # 写入M3U
        f_m3u.write(f'#EXTINF:-1 tvg-id="{index}" tvg-name="{channel_name}" tvg-logo="{logo_url}" group-title="{category}",{channel_name}\n')
        f_m3u.write(f"{url}\n")
        
        # 写入TXT
        f_txt.write(f"{channel_name},{url}\n")


def main():
    """主函数"""
    try:
        processor = ChannelProcessor()
        template_file = "demo.txt"
        
        channels, template_channels = processor.filter_source_urls(template_file)
        processor.update_channel_urls_m3u(channels, template_channels)
        
        logging.info("频道处理完成")
        
    except Exception as e:
        logging.error(f"程序执行失败: {e}")
        raise


if __name__ == "__main__":
    main()
